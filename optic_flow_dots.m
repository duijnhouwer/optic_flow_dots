function [filename,metadata]=optic_flow_dots(varargin)
    
    %OPTIC_FLOW_DOTS    Generate optic flow movie files.
    %
    %   OPTIC_FLOW_DOTS generates an optic flow movie file that simulates
    %   an arbitrary translational and rotational motion of a camera
    %   through a cloud of dots. Dots are only visible within a unit sphere
    %   that is centered on and moves with the camera. This sphera has unit
    %   radius (diameter of two).
    %
    %   The translation and rotation parameters can be constant throughout
    %   the video, or dynamically change from frame to frame. See the
    %   descriptions of the 'trans_xyz', 'rot_xyz', and 'rot_dpf'
    %   parameters below for more information on this.
    %
    %   Settings can be controlled using the following name,value pair
    %   arguments (default values in brackets):
    %
    %       'n_ndots': The number of dots in the cloud (>visible dots).
    %           [500]
    %       'win_widhei_px': Width and height of the video in pixels.
    %           [500 500]
    %       'back_rgb': Color of the background in red,green,blue values
    %           between 0 and 1 or a color character (see: help plot).
    %           ['k']
    %       'dot_style': Cell array with name,value pairs as the builtin
    %           function plot takes tem (see: help plot).
    %           [{'wo', 'MarkerSize',4, 'MarkerFaceColor','w'}]
    %       'n_frames': The number of video frames to be generated. [100]
    %       'trans_xyz': The camera translation per frame, [X;Y;Z], with
    %           X=left-right , Y=up-down, Z=back-front. Should be a
    %           3-element column vector or a 3 x n_frames matrix with a
    %           column vector for each frame. The larger the values, the
    %           higher the translation speed. Keep in mind that the entire
    %           dot cloud has a radius of 1, so sensible values are
    %           typically (much) smaller than 1. [[0;0;0.05]]
    %       'rot_xyz': The camera rotation-axes. Format like trans_xyz. The
    %           length of this vector is irrelevant, it's the scalar
    %           rot_dpf (see below) that determines the rotation rate,
    %           i.e., [0;1;0] and [0;100;0] equivalently specify a vertical
    %           axes that can be used for sideways rotation of the camera.
    %           [[0;1;0]]
    %       'rot_dpf': The camera rotation-rate (in degrees per frame).
    %           Either be a scalar for constant rotation or a 1 x n_frames
    %           vector. [2]
    %       'dot_life_fr': The number of frames until a dot's position is
    %           reset to a random location in the cloud. A value of 2 means
    %           that the dots take a single step before being repositioned.
    %           A value of 1 means the stimulus is white noise. A value of 
    %           [0] means the dots have unlimited life.
    %       'viewport': Rectangle [Xmin Xmax Ymin Ymax] that acts as a
    %           window at Z=0. Default, [sind([-45 45 -45 45])], cuts the
    %           biggest possible square out of the Z=0 cross section of the
    %           spherical dot cloud (which has diameter 2).
    %       'video_filename': The video filename. Leave empty to not save a
    %           video. Extension will be autogenerated depending on
    %           'video_profile'. ['optic_flow_dots_video']
    %       'video_profile': The video profile, for example 'MPEG-4'. Call
    %           <a href="matlab:VideoWriter.getProfiles">VideoWriter.getProfiles</a> for a list of profiles available on
    %           your system with descriptions. ['Archival']
    %       'video_framerate': The frames per second of the video. [25]
    %
    %   filename = OPTIC_FLOW_DOTS(...) returns the name of the videofile
    %   (including the path).
    %
    %   [~,metadata] = OPTIC_FLOW_DOTS(...) returns all settings, the state
    %   of the random number generator as it was at the start of the
    %   simulation (to be able to exactly replicate it), and the date and
    %   start time of the simulation.
    %
    %   It would have been trivial to design this function to produce a 4D
    %   matrix (width x height x 3(RGB) x n_frames) but saving the frames
    %   as a movie file on disk scales better to long and large field
    %   animations than keeping all frames in RAM. Use VideoReader to read
    %   the frames from the file one-by-one, or all at once, or in any
    %   desired subset. Note, however, that this is only equivalent to
    %   creating the entire stack in one go when no or lossless
    %   video compression is used. So if perfect fidelity is desired, use
    %   for example Archival (the default) instead of a profile with lossy
    %   compression such as MPEG-4. Call <a href="matlab:VideoWriter.getProfiles">VideoWriter.getProfiles</a> for a
    %   list of video profiles available on your system with descriptions.
    %
    %   Example:
    %       fclose('all');
    %       rng(100);
    %       vidfile = optic_flow_dots( 'trans_xyz',[0;0;-0.02] ...
    %           ,'rot_xyz',[0;0;1], 'rot_dpf',2 ...
    %           ,'dot_style',{'r*','MarkerSize',5} ...
    %           ,'video_filename','test','video_profile','MPEG-4');
    %
    %   Tips: 
    %      - Use implay(vidfile) to view the movie. 
    %      - Use V=VideoReader(vidfile); all_frames=V.read; to convert 
    %        the entire video to a matrix.
    %      - See VideoReader for more ways to get the frames from the
    %        movie file.
    %   
    %   See also: VideoWriter, VideoWriter.getProfiles, VideoReader,
    %   getframe

    %   BSD 3-Clause License Copyright (c) 2019, Jacob Duijnhouwer
    
    p=inputParser;
    is_natural=@(x)isnumeric(x) && isreal(x) && all(rem(x,1)==0) && all(x>0);
    is_color=@(x)((isnumeric(x) && numel(x)==3 && all(x>=0) && all(x<=1)) || any(x=='bgrcmykw'));
    p.addOptional('n_dots',500,@(x)is_natural(x) && numel(x)==1);
    p.addOptional('win_widhei_px',[500 500],@(x)is_natural(x) && numel(x)==2);
    p.addOptional('back_rgb','k',@(x)is_color(x));
    p.addOptional('dot_style',{'wo','MarkerSize',4,'MarkerFaceColor','w'});
    p.addOptional('n_frames',100,@(x)is_natural(x) && numel(x)==1);
    p.addOptional('trans_xyz',[0;0;0.05],@(x)isnumeric(x) && isreal(x) && size(x,1)==3);
    p.addOptional('rot_xyz',[0;1;0],@(x)isnumeric(x) && isreal(x) && size(x,1)==3);
    p.addOptional('rot_dpf',1,@(x)isnumeric(x) && isreal(x));
    p.addOptional('dot_life_fr',10,@(x)is_natural(x) || x==0);
    p.addOptional('viewport',sind([-45 45 -45 45]),@(x)isnumeric(x) && numel(x)==4 && x(1)<x(2) && x(3)<x(4));
    p.addOptional('video_filename','optic_flow_dots_video',@(x)ischar(x) || isempty(x));
    p.addOptional('video_profile','Archival',@ischar);
    p.addOptional('video_framerate',25,@isnumeric);
    p.parse(varargin{:});

    % Open the videowriter object. Do this dirst because this step has the
    % highest likelihood of failing, for example if a file with the same
    % name is still open somewhere.
    try
        if ~isempty(p.Results.video_filename)
            vid_obj = VideoWriter(p.Results.video_filename,p.Results.video_profile);
            vid_obj.FrameRate = p.Results.video_framerate;
            open(vid_obj);
        end
    catch me
        keyboard
    end
    
    % Create the metadata
    metadata=p.Results;
    metadata.video_filename=fullfile(vid_obj.Path,vid_obj.Filename);
    metadata.start_rng_state=rng;
    metadata.start_date=datestr(clock,0);
    
    % check that the transformation is constant or dynamic per frame, check
    % for correct input format, too (3x1 or 3xN_frames matrices)
    err={};
    if ~any(size(p.Results.trans_xyz,2)==[1 p.Results.n_frames])
        err{end+1}='trans_xyz must be a 3 element column vector or a 3 x n_frames matrix';
    end
    if ~any(size(p.Results.rot_xyz,2)==[1 p.Results.n_frames])
        err{end+1}='rot_xyz must be a 3 element column vector or a 3 x n_frames matrix';
    end
    if ~any(numel(p.Results.rot_dpf)==[1 p.Results.n_frames])
        err{end+1}='rot_dpf must be a scalar or a vector with n_frames elements';
    end
    if ~isempty(err)
        error([mfilename ':wrongtransform'],'  %s\n',err{:});
    end
    
    % Make the transformation matrix for all frames
    transformatrix=cell(p.Results.n_frames,1);
    for i=1:p.Results.n_frames
        R=p.Results.rot_xyz(:,mod(i-1,size(p.Results.rot_xyz,2))+1);
        T=p.Results.trans_xyz(:,mod(i-1,size(p.Results.trans_xyz,2))+1);
        A=p.Results.rot_dpf(mod(i-1,numel(p.Results.rot_dpf))+1);
        transformatrix{i}=makehgtform('axisrotate',R,-A/180*pi,'translate',-T);
    end
    
    % Create the figure window
    fig=figure('Name', mfilename);
    fig.NumberTitle='off';
    fig.CloseRequestFcn=@(~,~,~)evalin('caller','figure_close_requested=true;');
    fig.Position=[0 0 p.Results.win_widhei_px(:)'];
    fig.Units='pixels';
    fig.MenuBar='none';
    fig.Renderer='OpenGL';
    fig.Color=p.Results.back_rgb;
    movegui(fig,'center');
    
    % Create the axes and fix them
    ax=axes(fig);
    ax.Position=[0 0 1 1]; % fill the entire figure window
    ax.Color=p.Results.back_rgb;
    ax.XLimMode='manual';
    ax.XLim=p.Results.viewport(1:2);
    ax.YLimMode='manual';
    ax.YLim=p.Results.viewport(3:4);
    hold(ax,'on')
    axis(ax,'off');
    drawnow
    
    % Create a unit box with n_dots random dots
    dots_xyz=rand(3,p.Results.n_dots)*2*-1;
    dots_xyz=[dots_xyz; ones(1,p.Results.n_dots)]; % add an extra row to allow multiplication with 4x4 transformation matrix
    
    % If the dots are to have limited lifetime, set there remaining frames now
    if p.Results.dot_life_fr>0
        dots_frames_left=randi(p.Results.dot_life_fr,1,p.Results.n_dots);
    end
    
    % Draw until all frames are completed or until user closes window
    figure_close_requested=false;
    for i=1:p.Results.n_frames
        % stop if the user closes the window
        if figure_close_requested
            break;
        end
        
        % Update the name of the figure to represent progress
        fig.Name=sprintf('Recording: %s (%d/%d frs)',p.Results.video_filename,i,p.Results.n_frames); 
        
        % Apply transformation
        dots_xyz=transformatrix{i}*dots_xyz;
        if ~all(dots_xyz(4,:)==1)
            keyboard
        end
        
        % Refresh dots that have reached the end of their lifetime
        if p.Results.dot_life_fr>0
            dots_frames_left=dots_frames_left-1;
            expired=dots_frames_left==0;
            % Give new random positions to the expired dots
            dots_xyz(1:3,expired)=rand(3,sum(expired))*2*-1;
            % Refresh their frames_left counter
            dots_frames_left(expired)=p.Results.dot_life_fr;
        end
        
        % Detect dot coordinates that need wrapping (outside unit box)
        too_neg=dots_xyz<-1;
        too_pos=dots_xyz>1;
        % Get new random coordinates for all dots, store current in
        % prewrap_xyz
        prewrap_xyz=dots_xyz;
        dots_xyz=[rand(3,p.Results.n_dots)*2*-1 ; ones(1,p.Results.n_dots)];
        % Put all XYZ-s back of the dots that were fine (within the box)
        % and, of the dots that were not fine, only the offending
        % coordinates (so that they can be wrapped to the other side of the
        % box in the next step)
        fine=repmat(~any(too_neg & too_pos),4,1);
        dots_xyz(fine|too_neg|too_pos)=prewrap_xyz(fine|too_neg|too_pos);
        % Wrap the offending coordinates so that they are fine now
        dots_xyz(too_neg)=dots_xyz(too_neg)+2;
        dots_xyz(too_pos)=dots_xyz(too_pos)-2;
        
        % Detect which dots are in unit sphere and in front of camera
        visible=vecnorm(dots_xyz(1:3,:))<=1 & dots_xyz(3,:)>0;
        xx=dots_xyz(1,visible)./(dots_xyz(3,visible)+0);
        yy=dots_xyz(2,visible)./(dots_xyz(3,visible)+0);
        
        % Clear the axes and plot the dots
        cla(ax)
        plot(ax,xx,yy,p.Results.dot_style{:});
        
        % flush the stack 
        drawnow;
        
        % wait a little bit to allow matlab to detect window closure
        pause(0.001);
        
        % If requested, append a frame to the video
        if ~isempty(p.Results.video_filename)
            fr=getframe(ax);
            if strcmpi(p.Results.video_profile,'Grayscale Avi')
                fr.cdata=mean(double(fr.cdata),3)/255;
            end
            writeVideo(vid_obj,fr);
        end

    end
    
    % close the window
    delete(fig);
    
    % close the video file and create output 'filename'
    if exist('vid_obj','var')
        filename=fullfile(vid_obj.Path,vid_obj.Filename);
        close(vid_obj);
    else
        filename='';
    end
end
